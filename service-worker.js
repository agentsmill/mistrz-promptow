const CACHE_NAME="mistrz-promptow-v1",STATIC_ASSETS=["/","/index.html","/manifest.json","/favicon.ico","/static/js/main.js","/static/css/main.css"];function handleApiRequest(e){e.respondWith(fetch(e.request).then((e=>e)).catch((()=>caches.match(e.request))))}async function syncUserProgress(){try{const e=await openDatabase(),t=await getPendingOperations(e);if(0===t.length)return;for(const n of t)try{(await fetch("/api/sync",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n.data)})).ok&&await deletePendingOperation(e,n.id)}catch(e){console.error("Error syncing operation:",e)}}catch(e){console.error("Error in syncUserProgress:",e)}}function openDatabase(){return new Promise(((e,t)=>{const n=indexedDB.open("MistrzPromptowDB",1);n.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains("pendingSync")||t.createObjectStore("pendingSync",{keyPath:"id",autoIncrement:!0})},n.onsuccess=t=>{e(t.target.result)},n.onerror=e=>{t(e.target.error)}}))}function getPendingOperations(e){return new Promise(((t,n)=>{const r=e.transaction(["pendingSync"],"readonly").objectStore("pendingSync").getAll();r.onsuccess=()=>{t(r.result)},r.onerror=()=>{n(r.error)}}))}function deletePendingOperation(e,t){return new Promise(((n,r)=>{const s=e.transaction(["pendingSync"],"readwrite").objectStore("pendingSync").delete(t);s.onsuccess=()=>{n()},s.onerror=()=>{r(s.error)}}))}self.addEventListener("install",(e=>{e.waitUntil(caches.open(CACHE_NAME).then((e=>(console.log("Opened cache"),e.addAll(STATIC_ASSETS))))),self.skipWaiting()})),self.addEventListener("activate",(e=>{const t=[CACHE_NAME];e.waitUntil(caches.keys().then((e=>Promise.all(e.map((e=>-1===t.indexOf(e)?caches.delete(e):null)))))),self.clients.claim()})),self.addEventListener("fetch",(e=>{if(e.request.url.startsWith(self.location.origin))return e.request.url.includes("/api/")?handleApiRequest(e):void e.respondWith(caches.match(e.request).then((t=>{if(t)return t;const n=e.request.clone();return fetch(n).then((t=>{if(!t||200!==t.status||"basic"!==t.type)return t;const n=t.clone();return caches.open(CACHE_NAME).then((t=>{t.put(e.request,n)})),t})).catch((()=>"navigate"===e.request.mode?caches.match("/offline.html"):null))})))})),self.addEventListener("sync",(e=>{"sync-user-progress"===e.tag&&e.waitUntil(syncUserProgress())}));